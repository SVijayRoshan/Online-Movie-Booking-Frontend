BUILD A PRODUCTION-LIKE FRONTEND: Online Movie Booking (FRONT-END ONLY)

Objective:
Create a fully runnable, front-end-only React application (Vite + TypeScript) that reproduces a typical movie-ticket booking site (movie listings → movie detail → showtimes → seat selection → checkout → booking history). The app must be production-minded (accessible, responsive, performant) but use an in-memory/mock API so it can run locally without a backend.

Top-level constraints:
- Tech: Vite + React + TypeScript. Use React Router v6. Styling with Tailwind CSS (provide tailwind.config.js and postcss.config.js).
- Deliverables: full file tree + exact contents for every file necessary to run (source files, config files, README). Provide unit-test examples and an E2E test scenario (e.g., Cypress/Playwright pseudocode is OK).
- Single-reply output: include the file tree and each file content. Don’t ask clarifying questions — pick sensible defaults.
- Mock API: implement `src/services/mockApi.ts` (in-memory) with deterministic sample data and the seat-locking contract below. Also provide `src/services/api.ts` as a wrapper that can be swapped to real endpoints via `API_BASE_URL` env var.
- Use TypeScript types in `src/types` and ensure components are strongly typed.

User stories & required pages/components:
1. Home / Movie list
   - Search, filter (genre, date, theatre), sort (popular/new), pagination or infinite scroll.
2. Movie detail
   - Synopsis, runtime, poster, rating, shows grouped by date and theatre. "Select seats" CTA per show.
3. Seat selection
   - Visual seat map grid (grouped rows), seat states: available / booked / locked. Keyboard accessible selection (arrow keys + Enter), selection limit configurable.
   - Allow multi-seat selection, show total price, and "Lock seats" action that calls mock API and returns `lockToken`.
   - Handle partial lock failures: show which seats failed and let user retry or choose other seats.
4. Checkout
   - Show booking summary, user details form, mock payment gateway with deterministic success/fail toggle, and confirm booking.
   - Confirming booking calls mock `POST /bookings` with lockToken and returns booking id.
5. Authentication (frontend-mock)
   - Login/Register with mock JWT stored in memory/localStorage. Protect checkout & profile routes.
6. Profile (Booking history)
   - Show user's bookings, their details, and a printable ticket (front-end only).
7. Admin (frontend-only)
   - Add/edit/delete movie + shows that change the in-memory dataset.
8. Loading & error states for all network flows. Offline messaging for critical actions.

Mock API contract (explicit JSON shapes — frontend must implement these):
- GET /movies
  Response: 200 OK
  [
    { id, title, synopsis, posterUrl, duration, genres[], rating, shows[] }
  ]

- GET /movies/:id
  Response: 200 OK
  { id, title, synopsis, posterUrl, duration, genres[], rating, shows[] }

- GET /shows/:id
  Response: 200 OK
  { id, movieId, theatre, date, time, price, seatsLayout: [ { id, row, number, state: "available"|"booked", price } ] }

- POST /shows/:id/lock
  Request body: { seatIds: string[], holdSeconds?: number }
  Response: 200 OK
  { lockToken: string, lockedSeats: string[], failedSeats: string[], expiresAt: ISOString }

- POST /bookings
  Request body: { userId, showId, seatIds: string[], lockToken }
  Response: 201 Created
  { id, userId, showId, seats: [{id,row,number,price}], total, createdAt }

- GET /bookings?userId=<id>
  Response: 200 OK
  [booking...]

Non-functional requirements:
- Accessibility: seat buttons must be keyboard-navigable with aria labels; color contrast must be adequate; provide ARIA alert on lock failures or expiries.
- Performance: route-level code splitting; lazy load poster images; memoize seat list rendering for large seat maps.
- Responsiveness: design for mobile first; provide explicit breakpoints (mobile, tablet, desktop) and ensure seat map is usable on small screens (zoom/scroll).
- Testability: isolate seat selection & lock logic into pure hooks/functions with unit tests (example with Jest).
- Swap to real backend: code must use a single `api` wrapper (e.g., `src/services/api.ts`) so switching from mock to real endpoints is a single change.

Acceptance criteria (automatable):
- AC1: Visiting `/` shows movies. Clicking a movie opens `/movie/:id`.
- AC2: Clicking "Select Seats" loads a seat map; available/booked seats render correctly.
- AC3: Selecting seats and calling lock returns `lockToken` and navigates to checkout with `lockToken`.
- AC4: Confirm booking with valid lockToken returns booking and seats become `booked` in mock store.
- AC5: If lock expires or seats were locked by another simulated user, UI displays which seats failed and prevents booking.
- AC6: Unauthenticated access to `/checkout` or `/profile` redirects to `/login`.

Deliver output format:
- Provide a project file tree and then the full code content for every file listed including:
  - package.json (with relevant scripts)
  - index.html
  - tailwind.config.js, postcss.config.js
  - src/* files (main, App, pages, components, services, types, context)
  - README.md with run instructions and how to switch to a real backend
  - Example test file(s): one unit test for seat selection logic and one E2E test scenario description

Extra clarifications for the implementer (enforce quality):
- Use TypeScript types for all API responses and internal models.
- Seat-lock expiry must be visible (expiresAt or countdown) or at least properly handled.
- Provide clear comments in code for places to replace mockApi with real API.
- Keep third-party dependencies minimal; only include libraries you justify (e.g., react-router, tailwind, optionally react-query).
- For payment simulation, allow both success & failure via `?mode=success|fail` or a toggle button for deterministic tests.
- Include small set of sample posters in `/public/posters` (placeholder images OK) or use base64 inline placeholders.

Deliverables summary:
- A runnable repo scaffold and all files.
- README with usage + switching to real backend instructions.
- Unit test for seat-selection logic and a high-level E2E booking flow test case.

Finally:
1. First produce a short design-summary (1–2 paragraphs) that explains chosen architecture, mock API behavior, and trade-offs.
2. Then produce the complete file-list and file contents.
3. Keep explanations minimal after the code; the primary deliverable is the runnable code.

--- End of prompt ---
